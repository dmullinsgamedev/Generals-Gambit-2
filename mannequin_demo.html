<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mannequin Demo</title>
  <style>
    body { margin: 0; background: #bfe3f7; }
    #ui { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px; }
    button { margin: 2px 0; display: block; width: 120px; }
  </style>
</head>
<body>
<div id="ui">
  <button id="toggleHat">Toggle Hat</button>
  <button id="toggleStaff">Toggle Staff</button>
  <button id="toggleRobe">Toggle Robe</button>
  <button id="poseArms">Pose Arms</button>
  <button id="resetPose">Reset Pose</button>
  <button id="walkPose">Walk</button>
  <button id="castPose">Cast</button>
  <button id="idlePose">Idle</button>
</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { generateHumanoidSkeleton, attachToBone, poseHumanoid } from './src/generation/HumanoidSkeleton.js';
import { generateSkinnedRobe } from './src/generation/SkinnedRobe.js';

const { skeleton, bones } = generateHumanoidSkeleton();

// Store the skeleton's original local y-position
const skeletonDefaultY = skeleton.position.y;

// Store the head's original local y-position
const headDefaultY = bones.head.position.y;

// Accessories/overlays
let hat, brim, staff, robe;
let skinnedRobeObj;

function makeHat() {
  const group = new THREE.Group();
  const hatMesh = new THREE.Mesh(
    new THREE.ConeGeometry(0.13, 0.28, 16),
    new THREE.MeshStandardMaterial({ color: 0x7c3aed, metalness: 0.3, roughness: 0.7 })
  );
  hatMesh.position.y = 0.19;
  group.add(hatMesh);
  const brimMesh = new THREE.Mesh(
    new THREE.CylinderGeometry(0.16, 0.16, 0.022, 18),
    new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.7, roughness: 0.3 })
  );
  brimMesh.position.y = 0.07;
  group.add(brimMesh);
  group.hatMesh = hatMesh; // attach for animation
  return group;
}
function makeStaff() {
  const mesh = new THREE.Mesh(
    new THREE.CylinderGeometry(0.022, 0.022, 0.55, 10),
    new THREE.MeshStandardMaterial({ color: 0x8B5A2B, metalness: 0.2, roughness: 0.7 })
  );
  mesh.position.set(0, -0.18, 0.04);
  mesh.rotation.set(-Math.PI / 8, Math.PI / 12, Math.PI / 20);
  return mesh;
}

// Add minimal face (dots for eyes)
for (let i = -1; i <= 1; i += 2) {
  const eye = new THREE.Mesh(
    new THREE.SphereGeometry(0.014, 6, 6),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  eye.position.set(0.045 * i, 0.04, 0.11);
  bones.head.add(eye);
}

skeleton.scale.set(1.5, 1.5, 1.5);

// Three.js scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xbfe3f7);
const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 2, 6);
camera.lookAt(0, 1, 0);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
hemiLight.position.set(0, 10, 0);
scene.add(hemiLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 7.5);
scene.add(dirLight);
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshStandardMaterial({ color: 0x7ec850, roughness: 0.8 })
);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -1.2;
ground.receiveShadow = true;
scene.add(ground);
scene.add(skeleton);

// UI logic
let hatOn = false, staffOn = false, robeOn = false;
document.getElementById('toggleHat').onclick = () => {
  if (!hatOn) {
    hat = makeHat();
    attachToBone(bones, 'head', hat);
    hatOn = true;
  } else if (hat) {
    bones.head.remove(hat);
    hat = null;
    hatOn = false;
  }
};
document.getElementById('toggleStaff').onclick = () => {
  if (!staffOn) {
    staff = makeStaff();
    attachToBone(bones, 'hands.right', staff);
    staffOn = true;
  } else if (staff) {
    bones.hands.right.remove(staff);
    staff = null;
    staffOn = false;
  }
};
document.getElementById('toggleRobe').onclick = () => {
  if (!robeOn) {
    skinnedRobeObj = generateSkinnedRobe(bones);
    robe = skinnedRobeObj.mesh;
    attachToBone(bones, 'pelvis', robe);
    robeOn = true;
  } else if (robe) {
    bones.pelvis.remove(robe);
    robe = null;
    skinnedRobeObj = null;
    robeOn = false;
  }
};
document.getElementById('poseArms').onclick = () => {
  poseHumanoid(bones, {
    'upperArms.right': { z: -Math.PI/2.5 },
    'lowerArms.right': { z: -Math.PI/2.5 },
    'upperArms.left': { z: Math.PI/2.5 },
    'lowerArms.left': { z: Math.PI/2.5 }
  });
};
document.getElementById('resetPose').onclick = () => {
  poseHumanoid(bones, {
    'upperArms.right': { z: 0 },
    'lowerArms.right': { z: 0 },
    'upperArms.left': { z: 0 },
    'lowerArms.left': { z: 0 }
  });
};

let animationState = null;
let walkStartTime = 0;
let idleStartTime = 0;

function setAnimation(state) {
  animationState = state;
  if (state === 'walk') walkStartTime = performance.now();
  if (state === 'idle') idleStartTime = performance.now();
}

document.getElementById('walkPose').onclick = () => {
  setAnimation(animationState === 'walk' ? null : 'walk');
};
document.getElementById('idlePose').onclick = () => {
  setAnimation(animationState === 'idle' ? null : 'idle');
};

document.getElementById('castPose').onclick = () => {
  poseHumanoid(bones, {
    'upperArms.right': { z: -Math.PI/2.2, x: -Math.PI/12 },
    'lowerArms.right': { z: -Math.PI/2.5 },
    'upperArms.left': { z: Math.PI/8, x: Math.PI/10 },
    'lowerArms.left': { z: Math.PI/6 },
    'upperLegs.right': { x: 0 },
    'lowerLegs.right': { x: 0 },
    'upperLegs.left': { x: 0 },
    'lowerLegs.left': { x: 0 }
  });
};

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  if (animationState === 'walk') {
    const t = (now - walkStartTime) / 400;
    // Head bob and tilt (main motion)
    bones.head.position.y = headDefaultY + 0.0125 * Math.sin(t * 2); // bob around original position
    bones.head.rotation.z = 0.0125 * Math.sin(t);
    // Body bounce (half previous strength)
    skeleton.position.y = skeletonDefaultY + 0.0375 * Math.abs(Math.sin(t));
    poseHumanoid(bones, {
      'upperArms.right': { x: Math.PI/4 * Math.sin(t) },
      'lowerArms.right': { x: Math.PI/8 * Math.sin(t) },
      'upperArms.left': { x: -Math.PI/4 * Math.sin(t) },
      'lowerArms.left': { x: -Math.PI/8 * Math.sin(t) },
      'upperLegs.right': { x: Math.PI/6 * Math.sin(t) },
      'lowerLegs.right': { x: -Math.PI/12 * Math.sin(t) },
      'upperLegs.left': { x: -Math.PI/6 * Math.sin(t) },
      'lowerLegs.left': { x: Math.PI/12 * Math.sin(t) }
    });
    // Hat: small secondary tilt (follow-through)
    if (hat && hat.hatMesh) {
      hat.hatMesh.position.y = 0.19;
      hat.hatMesh.rotation.z = 0.03 * Math.sin(t - 0.2);
    }
    // Animate robe (sway and bob)
    if (robe) {
      robe.rotation.z = 0.10 * Math.sin(t);
      robe.position.y = -0.08 + 0.01 * Math.sin(t * 2);
    }
  } else if (animationState === 'idle') {
    bones.head.position.y = headDefaultY;
    bones.head.rotation.z = 0;
    skeleton.position.y = skeletonDefaultY;
    if (hat && hat.hatMesh) {
      hat.hatMesh.position.y = 0.19;
      hat.hatMesh.rotation.z = 0;
    }
    if (robe) {
      robe.rotation.z = 0;
      robe.position.y = -0.08;
    }
  }
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html> 